/*! contentful-parsers v0.2.12 | (c) 2020 Ryan Hefner | MIT License | https://github.com/ryanhefner/contentful-parsers.git !*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global['contentful-parsers'] = {}));
}(this, (function (exports) { 'use strict';

  /**
   * Flattens a Contentful data response, extracting the fields from child
   * objects and setting them to the parent name.
   *
   * @param  {Object} data
   * @return {Object}
   */
  function fieldsParser (data, props) {
    if (props === void 0) {
      props = {
        include: 10
      };
    }

    /**
     * Check to see if the object passed is an object that contains only a `sys`
     * property and no feields. If so, either the model is empty, draft, or unpublished.
     *
     * @param  {Object} object
     * @return {boolean}
     */
    function emptyModel(object) {
      return !!(typeof object === 'object' && object.hasOwnProperty('sys') && Object.keys(object).length === 1);
    }
    /**
     * Handle parsing non-field value objects, cleaning empty value objects that
     * contain no fields or filtering object arrays that contain empty objects with
     * just sys defined. Or, simply returning the value, unmanipulated.
     *
     * @param  {Object} object
     * @return {?any}
     */


    function parseValue(value, depth) {
      if (depth === void 0) {
        depth = 0;
      }

      // If value is an object and only contains a sys property, just return null
      // since itâ€™s either an empty or unpublished entry
      if (emptyModel(value)) {
        return null;
      }

      if (Array.isArray(value)) {
        return value.filter(function (item) {
          return !emptyModel(item);
        }).map(function (item) {
          return item && typeof item === 'object' && item.fields ? parseFields(item.fields, item.sys, {}, depth + 1) : parseValue(item, depth + 1);
        });
      }

      return value;
    }
    /**
     * Parse over a fields object, parsing child fields or building rest of object.
     *
     * @param  {Object} fieldsObject - fields object to iterate over and flatten into objectRef
     * @param  {Object} sys - sys object associated with fieldsObject
     * @param  {Object} objectRef - Compiled object that flattens the field objects
     * @return {Object}
     */


    function parseFields(fieldsObject, sys, objectRef, depth) {
      if (objectRef === void 0) {
        objectRef = {};
      }

      if (depth === void 0) {
        depth = 0;
      }

      if (!fieldsObject || typeof fieldsObject !== 'object') {
        return objectRef;
      }

      if (depth >= props.include) {
        return objectRef;
      }

      var objectRefClone = Object.assign({}, objectRef); // Iterate over fieldObject keys, rercursively parsing child objects that
      // contain fields, or parsing non-fields-child objects/entries

      Object.keys(fieldsObject).forEach(function (key) {
        objectRefClone[key] = fieldsObject[key].fields ? parseFields(fieldsObject[key].fields, fieldsObject[key].sys, objectRefClone[key], depth + 1) : parseValue(fieldsObject[key], depth + 1);
      }); // Apply typeNameKey/value to each fields object to define the Contentful model type

      var contentTypeId = sys && sys.contentType && sys.contentType.sys && sys.contentType.sys.id;

      if (!!contentTypeId) {
        /* eslint-disable */
        objectRefClone['id'] = sys.id;
        objectRefClone['__typename'] = sys.contentType.sys.id;
        /* eslint-enable */
      } // Apply updatedAt


      if (sys && sys.updatedAt) {
        objectRefClone['updatedAt'] = sys.updatedAt;
      } // Apply createdAt


      if (sys && sys.createdAt) {
        objectRefClone['createdAt'] = sys.createdAt;
      }

      return objectRefClone;
    }

    return parseFields(data.fields, data.sys);
  }

  exports.fieldsParser = fieldsParser;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
/* follow me on Twitter! @ryanhefner */
